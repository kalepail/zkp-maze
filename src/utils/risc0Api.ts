import { RISC0_API_URL } from '../constants/provider';

// RISC Zero Receipt type (simplified)
export interface Receipt {
  journal: {
    bytes: number[];
  };
  // Other receipt fields omitted for brevity
  [key: string]: any;
}

// Types matching the RISC Zero API server
export interface MazeProof {
  maze_seed: number;
  grid_hash: number[];
  grid_data: number[][];
  receipt: Receipt;
}

export interface PathProof {
  maze_seed: number;
  is_valid: boolean;
  receipt: Receipt;
}

export interface GenerateMazeRequest {
  seed: number;
}

export interface GenerateMazeResponse {
  success: boolean;
  maze_proof?: MazeProof;
  error?: string;
}

export interface VerifyPathRequest {
  maze_proof: MazeProof;
  moves: number[];
}

export interface VerifyPathResponse {
  success: boolean;
  path_proof?: PathProof;
  error?: string;
}

export interface VerifyProofRequest {
  path_proof: PathProof;
}

export interface VerifyProofResponse {
  success: boolean;
  is_valid: boolean;
  maze_seed: number;
  error?: string;
}

export interface HealthResponse {
  status: string;
  service: string;
}

/**
 * RISC Zero API Client
 */
export class Risc0ApiClient {
  private baseUrl: string;

  constructor(baseUrl: string = RISC0_API_URL) {
    this.baseUrl = baseUrl;
  }

  /**
   * Check if the RISC Zero API server is healthy
   */
  async checkHealth(): Promise<HealthResponse> {
    const response = await fetch(`${this.baseUrl}/health`);
    if (!response.ok) {
      throw new Error(`Health check failed: ${response.statusText}`);
    }
    return response.json();
  }

  /**
   * Generate a maze proof from a seed
   */
  async generateMaze(seed: number): Promise<MazeProof> {
    const request: GenerateMazeRequest = { seed };

    const response = await fetch(`${this.baseUrl}/api/generate-maze`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Failed to generate maze: ${text}`);
    }

    const data: GenerateMazeResponse = await response.json();

    if (!data.success || !data.maze_proof) {
      throw new Error(data.error || 'Failed to generate maze proof');
    }

    return data.maze_proof;
  }

  /**
   * Verify a path through the maze and generate a proof
   */
  async verifyPath(mazeProof: MazeProof, moves: number[]): Promise<PathProof> {
    const request: VerifyPathRequest = {
      maze_proof: mazeProof,
      moves,
    };

    const response = await fetch(`${this.baseUrl}/api/verify-path`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Failed to verify path: ${text}`);
    }

    const data: VerifyPathResponse = await response.json();

    if (!data.success || !data.path_proof) {
      throw new Error(data.error || 'Failed to verify path proof');
    }

    return data.path_proof;
  }

  /**
   * Cryptographically verify a path proof receipt
   * This checks the receipt signature and ensures it was generated by the correct program
   */
  async verifyProof(pathProof: PathProof): Promise<VerifyProofResponse> {
    const request: VerifyProofRequest = {
      path_proof: pathProof,
    };

    const response = await fetch(`${this.baseUrl}/api/verify-proof`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Failed to verify proof: ${text}`);
    }

    const data: VerifyProofResponse = await response.json();

    if (!data.success) {
      throw new Error(data.error || 'Failed to verify proof');
    }

    return data;
  }

  /**
   * Format a RISC Zero receipt for display
   * Shows a shorthand representation of the nested proof structure
   */
  formatReceipt(receipt: Receipt): string {
    // Calculate receipt size from JSON serialization
    const receiptStr = JSON.stringify(receipt);
    const receiptKB = (receiptStr.length / 1024).toFixed(2);

    // Create a compact representation
    const lines = [
      '=== RISC Zero Receipt ===',
      `Size: ${receiptKB} KB`,
      `Type: SuccinctReceipt (STARK)`,
      '',
      'Structure:',
      '  - InnerReceipt: Composite/Succinct proof',
      '  - Seal: Cryptographic attestation',
      '  - Claim: Pre/post state + journal digest',
      '',
      'Journal:',
      `  ${this.formatJournal(receipt.journal?.bytes || [])}`,
    ];

    return lines.join('\n');
  }

  /**
   * Format a journal for display
   */
  formatJournal(journalBytes: number[]): string {
    if (!journalBytes || journalBytes.length === 0) return '(empty)';

    // Show first few and last few entries
    const preview = journalBytes.slice(0, 8);
    const suffix = journalBytes.length > 8 ? ` ... (${journalBytes.length} bytes total)` : '';

    return `[${preview.join(', ')}${suffix}]`;
  }
}

// Export singleton instance
export const risc0Api = new Risc0ApiClient();
