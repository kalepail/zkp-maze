import { RISC0_API_URL } from '../constants/provider';

// Receipt kind options
export type ReceiptKind = 'composite' | 'succinct' | 'groth16';

// RISC Zero Receipt type (simplified)
export interface Receipt {
  journal: {
    bytes: number[];
  };
  // Other receipt fields omitted for brevity
  [key: string]: any;
}

// Types matching the RISC Zero API server
export interface MazeProof {
  maze_seed: number;
  grid_hash: number[];
  grid_data: number[][];
  receipt: Receipt;
  receipt_kind: ReceiptKind;
}

export interface PathProof {
  maze_seed: number;
  is_valid: boolean;
  receipt: Receipt;
  receipt_kind: ReceiptKind;
}

export interface GenerateMazeRequest {
  seed: number;
  receipt_kind?: ReceiptKind;
}

export interface GenerateMazeResponse {
  success: boolean;
  maze_proof?: MazeProof;
  error?: string;
}

export interface VerifyPathRequest {
  maze_proof: MazeProof;
  moves: number[];
  receipt_kind?: ReceiptKind;
}

export interface VerifyPathResponse {
  success: boolean;
  path_proof?: PathProof;
  error?: string;
}

export interface VerifyProofRequest {
  path_proof: PathProof;
}

export interface VerifyProofResponse {
  success: boolean;
  is_valid: boolean;
  maze_seed: number;
  error?: string;
}

export interface HealthResponse {
  status: string;
  service: string;
}

/**
 * RISC Zero API Client
 */
export class Risc0ApiClient {
  private baseUrl: string;

  constructor(baseUrl: string = RISC0_API_URL) {
    this.baseUrl = baseUrl;
  }

  /**
   * Check if the RISC Zero API server is healthy
   */
  async checkHealth(): Promise<HealthResponse> {
    const response = await fetch(`${this.baseUrl}/health`);
    if (!response.ok) {
      throw new Error(`Health check failed: ${response.statusText}`);
    }
    return response.json();
  }

  /**
   * Generate a maze proof from a seed
   * @param seed - The seed to generate the maze from
   * @param receiptKind - The type of receipt to generate (defaults to 'succinct')
   */
  async generateMaze(seed: number, receiptKind: ReceiptKind = 'succinct'): Promise<MazeProof> {
    const request: GenerateMazeRequest = { seed, receipt_kind: receiptKind };

    const response = await fetch(`${this.baseUrl}/api/generate-maze`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Failed to generate maze: ${text}`);
    }

    const data: GenerateMazeResponse = await response.json();

    if (!data.success || !data.maze_proof) {
      throw new Error(data.error || 'Failed to generate maze proof');
    }

    return data.maze_proof;
  }

  /**
   * Verify a path through the maze and generate a proof
   * @param mazeProof - The maze proof to verify against
   * @param moves - The moves to verify
   * @param receiptKind - Optional receipt kind override (defaults to maze proof's receipt kind)
   */
  async verifyPath(mazeProof: MazeProof, moves: number[], receiptKind?: ReceiptKind): Promise<PathProof> {
    const request: VerifyPathRequest = {
      maze_proof: mazeProof,
      moves,
      receipt_kind: receiptKind,
    };

    const response = await fetch(`${this.baseUrl}/api/verify-path`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Failed to verify path: ${text}`);
    }

    const data: VerifyPathResponse = await response.json();

    if (!data.success || !data.path_proof) {
      throw new Error(data.error || 'Failed to verify path proof');
    }

    return data.path_proof;
  }

  /**
   * Cryptographically verify a path proof receipt
   * This checks the receipt signature and ensures it was generated by the correct program
   */
  async verifyProof(pathProof: PathProof): Promise<VerifyProofResponse> {
    const request: VerifyProofRequest = {
      path_proof: pathProof,
    };

    const response = await fetch(`${this.baseUrl}/api/verify-proof`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Failed to verify proof: ${text}`);
    }

    const data: VerifyProofResponse = await response.json();

    if (!data.success) {
      throw new Error(data.error || 'Failed to verify proof');
    }

    return data;
  }

  /**
   * Format a RISC Zero receipt for display
   * Shows a shorthand representation of the nested proof structure
   */
  formatReceipt(receipt: Receipt, receiptKind: ReceiptKind): string {
    // Calculate receipt size from JSON serialization
    const receiptStr = JSON.stringify(receipt);
    const receiptKB = (receiptStr.length / 1024).toFixed(2);
    const receiptBytes = receiptStr.length;

    // Get receipt type details
    const typeInfo = this.getReceiptTypeInfo(receiptKind);

    // Format size with appropriate unit
    const sizeDisplay = receiptBytes < 1024
      ? `${receiptBytes} bytes`
      : receiptBytes < 1024 * 100
        ? `${receiptKB} KB`
        : `${(receiptBytes / (1024 * 1024)).toFixed(2)} MB`;

    // Create a compact representation
    const lines = [
      '=== RISC Zero Receipt ===',
      `Size: ${sizeDisplay}`,
      `Type: ${typeInfo.name} (${typeInfo.cryptoType})`,
      `Efficiency: ${typeInfo.description}`,
      '',
      'Structure:',
      `  - InnerReceipt: ${typeInfo.structure}`,
      '  - Seal: Cryptographic attestation',
      '  - Claim: Pre/post state + journal digest',
      '',
      'Journal:',
      `  ${this.formatJournal(receipt.journal?.bytes || [])}`,
    ];

    return lines.join('\n');
  }

  /**
   * Get receipt type information based on receipt kind
   */
  private getReceiptTypeInfo(receiptKind: ReceiptKind): {
    name: string;
    cryptoType: string;
    description: string;
    structure: string;
  } {
    switch (receiptKind) {
      case 'composite':
        return {
          name: 'Composite',
          cryptoType: 'STARK',
          description: 'Fast generation, large size (~1-2 MB)',
          structure: 'Multiple segment proofs',
        };
      case 'succinct':
        return {
          name: 'Succinct',
          cryptoType: 'STARK',
          description: 'Balanced size and verification (~200 KB)',
          structure: 'Compressed recursive proof',
        };
      case 'groth16':
        return {
          name: 'Groth16',
          cryptoType: 'SNARK',
          description: 'Ultra-compact, blockchain-friendly (~300 bytes)',
          structure: 'zkSNARK elliptic curve proof',
        };
    }
  }

  /**
   * Format a journal for display
   */
  formatJournal(journalBytes: number[]): string {
    if (!journalBytes || journalBytes.length === 0) return '(empty)';

    // Show first few and last few entries
    const preview = journalBytes.slice(0, 8);
    const suffix = journalBytes.length > 8 ? ` ... (${journalBytes.length} bytes total)` : '';

    return `[${preview.join(', ')}${suffix}]`;
  }
}

// Export singleton instance
export const risc0Api = new Risc0ApiClient();
